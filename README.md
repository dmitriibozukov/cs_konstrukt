# Конструктор ботов для проведения игровых тренировок в игре Counter-Strike
 
<img height="400" src="gif.gif">


## Обзор 
Данная работа посвящена созданию конструктора ботов для игры Counter-Strike. Исследование основано на анализе статистики количества игроков в видеоигры, методов искусственного интеллекта, позволяющих реализовать взаимодействие бота с игровым миром без вмешательства в файлы игры, автоматизации создания ботов для проведения игровых тренировок. Основными задачами является сбор данных для обучения модели, разработка и обучения модели выбранными методами, а также последующее тестирование против живых игроков. Результаты работы подтверждают эффективность конструктора за счет роста рейтинговых очков игроков, использующих конструктор. Работа также предлагает другие варианты использования конструктора. 

Для того, чтобы модуль мог обнаруживать объекты в реальном времени я решил выбрать архитектуру нейронных сетей YOLOv7 и обучить ее распознавать игровых персонажей игры кс. Она выделяется тем, что обрабатывает изображение в один проход (процедура обнаружения объектов выполняется за один раз без необходимости многократного анализа изображений). Также YOLO отличается высоким показателем обработки кадров в секунду. Главное ее преимущество в том, что она специально создана для обработки кадров в реальном времени. Например, архитектура YOLOv4 используется во многих городских камерах для обеспечения безопасности.
Для обучения был создан датасет, состоящий из 5112 изображений. К каждому изображению прикреплен файл txt, содержащий информацию о метках и классах на изображении. Метод разметки – YOLO, количество классов – 4(голова террориста, тело террориста, голова контр террориста, тело контр террориста). С помощью библиотеки MSS в отдельное окно выводится поток скриншотов из игры, в этом окне обученная модель YOLO обнаруживает игровых противников и возвращает координаты середины меток.
 
После того, как модель получила данные о метках и их местоположению алгоритм должен наводиться на цель и совершать стрельбу. Чтобы наводка происходила натурально и соответствовала паттерну передвижения курсора человека был произведен простой эксперимент: надо провести линию из бокового квадрата к центральному как можно быстрее (рис. 3). По итогам был выбран алгоритм WindMouse. Данный алгоритм был создан специально для симуляции движения курсора человеком. Основан на движении объекта под воздействием физических сил – сила ветра, гравитационное притяжение, трение. С помощью этих параметров пользователь может регулировать паттерн передвижения и тем самым выбрать для себя оптимальное ведение курсора ботом.

Для того, чтобы бот мог перемещаться по игровой карте был выбран метод поведенческого клонирования, т. к. для обучения не требуется вмешиваться в файлы игры. Также этот алгоритм обладает высокой стабильностью за счет того, что он повторяет действия эксперта. Важно при обучении использовать как можно больше данных, чтобы при обучении модель понимала, как ей действовать в каждой из ситуаций. Для обучения таким методом были собраны данные посредством записи игры эксперта. Каждые 50мс производилась сохранение состояния. Данные представляют собой numpy массивы, содержащие данные о пикселях в формате RGB и активной клавишей перемещения. Процесс обучения состоял из трех этапов. Сначала данные проходили через EfficientNetB0 для извлечения пространственных признаков. Затем признаки передавались в ConvLSTM, который моделировал временные зависимости и прогнозировал следующее действие на основе текущих и предыдущих кадров. На выходе добавлялся полносвязный слой, который предсказывал действие агента: движение вперед, движение влево, движение назад, движение вправо, состояние неактивности

1) Используйте dm_record_data.py для захвата данных как зритель, или dm_record_data_me_wasd.py для записи при активной игре. Это создает .npy файлы со скриншотами и метаданными.
2) Запустите dm_train_model.py для обучения модели передвижения.
3) Скрипт dm_run_agent.py запускает модель в окружении CS.
4) Запустите train.py для обучения модели передвижения.
5) Скрипт detect.py запускает модель в окружении CS.


## Датасет

Датасеты доступны по ссылке: https://drive.google.com/drive/folders/125MZLH2kxXwW9LOlgY0lTkiF8CbqpACJ?usp=sharing .

- ```dataset_dm_aim```
    - кол-во фалов: 22
    - размер: 3,5 GB
    - карта: aim_map
    - режим: deathmatch

- ```dataset_yolo```
    - кол-во фалов: 10224
    - размер: 5,38 GB
    - карта: dust2, aim, inferno, mirage
    - режим: deathmatch

### Рекомендуемые технические характеристики

Запуск данного конструктора требует наличия CUDA ядер в видеокарте компьютера. Данный конструктор тестировался на видеокарте RTX 3080. Таким образом, рекомендуемая видеопамять - 10Гб, количество CUDA ядер - 8000.

## Лицензия
Этот репозиторий может быть использован для личных проектов и открытых исследований. 

## Предупреждение
Хотя код не предназначен для читерства/взлома, существует вероятность того, что Valve может обнаружить использование некоторых из этих скриптов в игре (например, имитация движений мыши и анализ оперативной памяти), что, в свою очередь, может вызвать подозрения в читерстве. Мы не несем ответственности за подобные проблемы. Используйте его на свой страх и риск!

## Настройки Counter Strike
Несколько советов, которые могут помочь запустить агента на вашей локальной системе:

    - Game resolution: Normal 4:3, 1024×768, windowed
    - Mouse sensitivity: 2.50
    - Mouse raw input: Off
    - Reverse mouse: Off
    - Mouse acceleration: Off
    - Crosshair settings: Classic static, green – RGB: (46, 250, 42), length 4.3, thickness 1.8, gap 2.0, no outline, no centre dot. (Length 2.8 also used in some training data and demos.)
    - (Or use crosshair code: CSGO-UKcZG-QN8eW-WQMvd-NX6xr-RPqRP)
    - All graphics options: Lowest quality setting
    - Boost Player Contrast: Enabled
    - Multisampling AA Mode: 2x MSAA
    - HUD edge positions: as large as possible
    - HUD scale: 0.56
    - HUD color: Default
    - Radar HUD size: 0.80
    - Clear decals is bound to ‘n’ key (https://www.skinwallet.com/csgo/clear-decals-csgo/)
    - cl_righthand 1
    - viewmodel_offset_x 1
    - viewmodel_offset_y 1
    - viewmodel_offset_z  -1
    - viewmodel_fov 60
    - cl_bobamt_lat 0.33
    - cl_bobamt_vert 0.14
    - cl_bobcycle 0.98
    - cl_viewmodel_shift_left_amt 1.5
    - cl_viewmodel_shift_right_amt 0.75



